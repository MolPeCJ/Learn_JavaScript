### Алгоритмы

* поиска
* сортировки
* рекурсивные
* дейкстры для поиска кратчайшего пути в графе
* обхода деревьев
* кеширования

### Структуры

* массивы
* связный список
* очередь
* стэк
* сет
* мэп
* двоичное деревно 
* n-арное дерево
* графы

***

### Что такое алгоритм? Оценка сложности 
#### Определение алгоритма

Алгоритм - набор последовательных действий, решающих какую-либо задачу. В принципе любой фрагмент кода можно назвать алгоритмом. 

#### Оценка сложности алгоритма (на примере бинарного поиска)

Оценка их сложности происходит через  O(n), где O - большое, n - кол-во операций, за которое алгоритм приходит к финальному результату. При этом всегда указывается наихудшая ситуация. 
Представим, что у нас есть массив, состоящий из 10-ти элементов: 
`arr [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];`
В нем мы будем искать '3' - искомый элемент. В лучшем случае он будет первым, в худшем - последнем. Поэтому сложность этого алгоритма сложность будет равняться O(10). Алгоритм, кстати, называется 'Линейный поиск'.

Теперь попробуем то же самое с алгоритмом 'Бинарный поиск'. Он работает в разы быстрее, но подразумевается, что первоначально он отсортирован по порядку. 
Представим себе орфографический словарь, чтобы найти какое-нибудь слово, мы не будем листать весь словарь. Мы откроем его по середине и найдем букву. Или лучше найдем 7 в том же массиве из примера выше: 
`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] -> [5, 6, 7, 8, 9] -> [6, 7, 8] -> [6, 7] -> 7`
Cложность алгоритма: О(log2n).

Бинарный алгоритм гораздо эффективнее линейного! Например, для 1 млн элементов 1-й будет работать, внимание, 11 дней, а второй справится за 32 мс. 

***

### Алгоритмы сортировки 
#### Сортировка выбором

Есть массив неупорядоченных элементов:
`arr [6, 4, 3, 1, 7, 8, 4, 4, 3, 9];`
В нем мы будем искать минимальный элемент. Поменяем с текущим. Затем снова пробегаемся по массиву и находим минимальное значение. Снова меняем. И так до конца.

Cложность алгоритма: О(n ** n).

#### Пузырьковая сортировка

Принцип работы схож с предыдущим. Мы так же двойным циклом пробегаемся по элементам массива и сравниваем попарно лежащие элементы. Если a > b, то меняем их местами. Получается своего рода "всплытие". Самый большой элемент по ходу выполнения алгоритма "вслпывает наверх", поэтому и сортировка получила такое название. Сложность одинакова с предыдущим, но по факту он менее эффективен, так как итераций больше. 

Cложность алгоритма: О(n ** n).

#### Быстрая сортировка (сортировка Хоара)

Алгоритм является рекурсивным.  
Рекурсия - это функция, которая вызывает саму себя. Рекурсия обязательно должна иметь какое-то условие и какой-то случай, при котором вызов функции прекращается.  
Создается 2 массива: со значениями меньше и больше опорного. Затем массивы склеиваются вместе с опорным посередине. 

Сложность алгоритма: O(log2n * n).

### Графы

Что же такое графы?