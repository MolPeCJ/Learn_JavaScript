Алгоритмы
* поиска
* сортировки
* рекурсивные
* дейкстры для поиска кратчайшего пути в графе
* обхода деревьев
* кеширования

// Структуры
* массивы
* связный список
* очередь
* стэк
* сет
* мэп
* двоичное деревно 
* n-арное дерево
* графы

***

### Что такое алгоритм? Оценка сложности 

#### Определение алгоритма
Алгоритм - набор последовательных действий, решающих какую-либо задачу. В принципе любой фрагмент кода можно назвать алгоритмом. 

#### Оценка сложности алгоритма
Оценка их сложности происходит через  O(n), где O - большое, n - кол-во операций, за которое алгоритм приходит к финальному результату. При этом всегда указывается наихудшая ситуация. 
Представим, что у нас есть массив, состоящий из 10-ти элементов: 
`arr [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];`
В нем мы будем искать '3' - искомый элемент. В лучшем случае он будет первым, в худшем - последнем. Поэтому сложность этого алгоритма сложность будет равняться O(10). Алгоритм, кстати, называется 'Линейный поиск'.

Теперь попробуем то же самое с алгоритмом 'Бинарный поиск'. Он работает в разы быстрее, но подразумевается, что первоначально он отсортирован по порядку. 
Представим себе орфографический словарь, чтобы найти какое-нибудь слово, мы не будем листать весь словарь. Мы откроем его по середине и найдем букву. Или лучше найдем 7 в том же массиве из примера выше: 
`[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] -> [5, 6, 7, 8, 9] -> [6, 7, 8] -> [6, 7] -> 7`
Cложность алгоритма: О(log2n).

Бинарный алгоритм гораздо эффективнее линейного! Например, для 1 млн элементов 1-й будет работать, внимание, 11 дней, а второй справится за 32 мс. 

***

Линейный поиск

// Линейный поиск (поиск 3 среди массива цифр)
// Бинарный поиск ()