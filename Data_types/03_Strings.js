"use strict";
// Строки
// В JavaScript любые текстовые данные являются строками. Не существует отдельного типа "символ",
// который есть в ряде других языков. 
// Внутренний формат для строк - всегда UTF-16, вне зависимости от кодировки страницы

// Кавычки

// В JS есть разные типы кавычек.
// Строку можно создать с помощью одинарных, двойных либо обратных кавычек:
let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;
// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки,
// то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${}:
function sum(a, b) {
    return a + b;
}

console.log( `1 + 2 = ${sum(1, 2)}` ); // 1 + 2 = 3
// Еще одно преимущество обратных кавычек - они могут занимать более одной строки, вот так:
let guestList = `Guests:
Jhon,
Pete,
Mary`;

console.log (guestList); // все так и будет
// Одинарные и двойные кавычки в языке с незапамятных времен: тогда потребность в многострочных
// строках не учитывалась. Что касается обратных кавычек, они появились существенно позже, и
// поэтому они гибче

// Спецсимволы

// Многострочные строки также можно создавать с опомщью одинарных и двойных кавычек, используя
// так называемый "символ перевода строки", который записывается как \n:
let guestList1 = "Guests: \nJhon, \nPete, \nMary";

console.log(guestList1)
// Есть и другие, реже используемые спецсимволы. Вот список: *в уроке*
// Отдельного внимания заслуживает Юникод:
console.log( "\u00A9" ); // (c)
console.log( "\u{20331}" ); // китайский символ (длинный юникод)
console.log( "\u{1F60D}" ); // символ-смайлик улыбающегося лица (длинный юникод)
// Все спецсимволы начинаются с обратного слеша, \ - так называемого "символа экранирования".
// Он также используется, если необходимо вставить в строку кавычку:
console.log( "I\'m student" ); // I'm...
// При этом символ \ НЕ сохраняется в оперативную память со строкой. Если же нужен сам
// этот символ, то используют \\
console.log( "Example \\" ); // \

// Длина строки

// Свойство length содержит длину строки:
console.log( guestList1.length ); // 27
// Важно! length - это числовое свойство, а не функция
// Надо писать str.length, а не str.length()

// Доступ к символам (!)

// Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos].
// Также можно использовать метод charAt: str.charAt(pos). Первый символ занимает 0-ю полизицию:
let str = `Hello, World!`;

console.log( str[1] ); // e
console.log( str.charAt(str.length - 1) ); // !
// Квадратные скобки - современный способ получить символ, в то время как charAt существует в
// основном по историческим причинам. Разница между нили только в том, что если символ
// отсуствует, тогда [] вернет undefined, а charAT - пустую строку:
console.log( str[25] ); // undefined
console.log( str.charAt(25) ); // 
// Также можно перебрать строку посимвольно! используя for...of:
for (let char of "Hello") {
    console.log( char );
}

// Строки неизменяемы

// Содержание строки в JS нельзя изменить. Нельзя взять символ посередине и заменить его.
// Как только строка создана - она такая навсегда!
let str2 = "Hi";

//str2[0] = "a"; // ошибка
// Можно создать новую строку и записать ее в ту же самую переменную вместо старой
let example1 = "Hello, Kirill";
let example2 = "Hi, Tolya";

example1 = example2;
example2 = 'h' + example1[1] + example1[2];

console.log( example2 ); // Hi, Tolya || hi,

// Изменение регистра

// Методы toLowerCase() и toUpperCase() меняют регистр символов:
console.log( "Interface".toLocaleLowerCase() ); // interface
console.log( "Interface".toUpperCase() ); // INTERFACE
// Еслимы мы захотим перевести в другой регистр какой-то конкретный символ и показать его:
console.log( "Interface"[1].toUpperCase()); // N

// Поиск подстроки (!)

// Существует несколько способов поиска подстроки

// str.indexOf(substr, pos)
// Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на
// которой располагается совпадение, либо -1 при отсутствии совпадений
let str3 = "My wallet in unbroken";

console.log( str3.indexOf("w") ); // 3 - место расположения w в строке str3
console.log( str3.indexOf("z") ); // -1 - нет совпадений
console.log( str3.indexOf("e", 8) ); // 19, потому что поиск начался с 8ого символа
// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив
// очередную позицию, начинаем новый поиск со следующей:
let str4 = "My oslik ya-ya is watching TV";
let substr4 = "ya";

let pos = 0;
while(true) {
    let foundPos = str4.indexOf(substr4, pos); // тут находим 1-е вхождение, если таковое есть
    if (foundPos == -1) break; // обеспечивает выход в конце

    console.log( `It is here: ${foundPos}` );
    pos = foundPos + 1; // мы нашли и продолжаем уже со следующей позиции
}

// str.lastIndexOf(substr, position)
// Похожий на предыдущий метод. Ищет вхождения с конца строки к ее началу.
// Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки
// или начинающееся до (включительно) определенной позиции
let str5 = "I just love this world, love birds and animals";

console.log( str5.lastIndexOf("love") ); // 24

// Еще из интересностей! Если делать if с indexOf без != -1, то такая запись может
// показать неправильный результат:
let str6 = "Widget with id";

if (str6.indexOf("Widget")) {
    console.log( "Gotcha!" );
} else {
    console.log( "Error" ); // это и появится, хотя Widget есть
}
// Дело в том, что вхождение Widget начинается с 0-ого символа, поэтому возвращается 0
// и интерпретируется if как значение false. Поэтому надо делать if с != -1
if (str6.indexOf("Widget") != -1) {
    console.log( "Gotcha!" ); // сообщение появится
}

// Трюк с побитовым НЕ

// Существует старый трюк с использованием оператора НЕ - ~. Он приобразует число в 
// 32-разрядное целое со знаком (signed 32-bit integer). Дробная часть, в случае, если она
// присутствует, отбрасывается. Проще говоря: результат работы оператора - возвращение число +1:
console.log( ~-1 ); // 0
console.log( ~0 ); // 1
console.log( ~1 ); // 2
// Соответственно, прохождение проверки if ( ~str.indexOf("...") ) означает, то результат
// indexOf отличен от -1 и совпадение есть. Поэтому это иногда применяют, смотрится компактнее:
let str7 = "I love JavaScript";

if ( ~str7.indexOf("love") ) {
    console.log( "Gotcha!" ); // выведет
}

// includes, startsWith, endsWith (!)
// Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть
// подстрока substr, либо false, если нет.
// Это - правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:
console.log( str7.includes("love") ); // true
// Необязательный второй аргумент str.includes позволяет начать поиск с определенной позиции:
console.log( str7.includes("love", 8) ); // false
// Методы str.startsWith, str.ednsWith проверяют, начинается ли и заканчивается ли строка
// определенной подстрокой:
console.log( str7.startsWith("I") ); // true
console.log( str7.startsWith("love") ); // false
console.log( str7.endsWith("Script") ); // true
console.log( str7.endsWith("Java") ); // false

// Получение подстроки (!) - можно запомнить только slice

// В JS есть 3 метода для получения подстроки: substring, substr, slice
// str.slice(start [, end]) - возвращает часть строки от start до (не включая) end:
let str8 = "stringify";

console.log( str8.slice(0 , 5) ); // strin
// если аргумент end отсутствует, то возвращает все от заданного символа до конца
console.log( str8.slice(4) ); // ngify
// также для start/end можно задавать отрицательные значения. Это означает, что позиция
// определена как заданное количество символов с конца строки
console.log( str8.slice(-4, -1) ); // gif

// str.substring(start [, end]);
// Возвращает часть строки между start и end (не включая) end!
// Это почти то же, что и slice, но можно задавать start больше end.
// Если start больше end, то метод substring сработает так, как если бы аргументы были
// поменяны местами:
console.log( str8.substring(5, 0) ); // strin
// отрицательные значения substring, в отличие от slice, не поддерживает

// str.substr(start [, length])
// Возвращает часть строки от start длины length.
// В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:
console.log( str8.substr(2, 4) ); // ring, то есть начинаем от 2 и вперед на 4 символа
// значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:
console.log( str8.substr(-4, 3) ); // gif

// Сравнение строк

// Как мы уже знаем, строки сравниваются посимвольно в алфавитном порядке. Тем не менее, 
// есть некоторые нюансыЖ
// 1 - строчные буквы больше загланвых (знаю)
// 2 - буквы, имеющие диакритические знаки, идут "не по порядку": 'Österreich' > 'Zealand'

// Строки кодирются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть
// специальные методы, позволяющие получить символ по его коду и наоборот
// str.codePointAt(pos) - возвращает код для символа, находящегося на позиции pos:
console.log( "z".codePointAt()); // 122
console.log( "Z".codePointAt() ); // 90

// String.fromCodePoint(code) - создает символ по его коду code
console.log( String.fromCodePoint(90) ); // Z
// также можно добавлять юникодные символы по их кодам, используя \u с шестнадцатеричным кодом
console.log( "\u005a" ); // Z
// Давайте сделаем строку, содержащую символы с кодами от 65 до 220 - это латиница и еще
// некоторые распространенные символы:
let str9 = "";

for (let i = 65; i <= 220; i++) {
    str9 += String.fromCodePoint(i);
}

console.log( str9 );
// Как мы можем увидеть, сначала идут загланвые буквы, затем несколько спецсимволов, затем строчные
// и так далее. Теперь понятнее, почему a > Z, ведь символы сравниваются по кодам

// Правильные сравнение
// Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в 
// соответствии с правилами языка: 
// отрицательное число, если str меньше str2;
// положительное число, если str больше str2;
// 0, если строки равны
console.log( str.localeCompare(str8) ); // -1

// Как все устроено, Юникод
// Вернемся попозже

/////////////////////////////////////////////
///////////// Questions (1/4) ///////////////
/////////////////////////////////////////////

// Сделать первый символ заглавным
function ucFirst(str) {
    if (str == "") {
        return "";
    }

    let endStr = str[0].toUpperCase();

    for (let i = 1; i < str.length; i++) {
        endStr += str[i];
    }

    return endStr;
}

console.log( ucFirst("vasya") );

// Проверка на спам
function checkSpam(str) {
    for (let i = 0; i < str.length - 5; i++) {
        for (let j = 0; j < 5; j++) {
            if ((str[j + 0] == "V" || str[j + 0] == "v") &&
                (str[j + 1] == "I" || str[j + 1] == "i") &&
                (str[j + 2] == "A" || str[j + 2] == "a") &&
                (str[j + 3] == "G" || str[j + 3] == "g") &&
                (str[j + 4] == "R" || str[j + 4] == "r") &&
                (str[j + 5] == "A" || str[j + 5] == "a")) {
                    return true;
            }
        }
    }

    for (let i = 0; i < str.length - 3; i++) {
        for (let j = 0; j < 3; j++) {
            if ((str[j + 0] == "X" || str[j + 0] == "x") &&
                (str[j + 1] == "X" || str[j + 1] == "x") &&
                (str[j + 2] == "X" || str[j + 2] == "x")) {
                    return true;
            }
        console.log(str[j]);
        }
    }

    return false;
}

console.log( checkSpam("qwe xxxxx l") );

// Усечение строки 

// Выделить число

// 13.05.2022 -> 4/4

// Сделать первый символ заглавным
/* function ucFirst(str) {
    if (str == "") {
        return "";
    };
    
    let str2 = "";

    str2 += str[0].toUpperCase();

    for (let i = 1; i < str.length; i++) {
        str2 += str[i];
    }
    
    return str2;
}*/

// Проверка на спам
/*function checkSpam(str) {
    for (let i = 0; i < str.length; i++) {
        if (
            (str[i] == 'V' || str[i] == 'v') &&
            (str[i + 1] == 'I' || str[i + 1] == 'i') &&
            (str[i + 2] == 'A' || str[i + 2] == "a") &&
            (str[i + 3] == 'G' || str[i + 3] == 'g') &&
            (str[i + 4] == 'R' || str[i + 4] == 'r') &&
            (str[i + 5] == 'A' || str[i + 5] == 'a')
        ) {
            return true;
        };

        if (
            (str[i] == 'X' || str[i] == 'x') &&
            (str[i + 1] == 'X' || str[i + 1] == 'x') &&
            (str[i + 2] == 'X' || str[i + 2] == "x")
        ) {
            return true;
        };
    };
    return false;
}*/ 

// Усечение строки 
/*function truncate(str, maxLength) {
    let answer = "";

    if (str.length > maxLength) {
        for (let i = 0; i < maxLength - 1; i++) {
            answer += str[i];
        }
        answer += String.fromCharCode(8230);

        return answer.length;
    }

    return str;
}*/ 

// Выделить число
/* function extractCurrencyValue(str) {
    let answer = "";

    for(let i = 1; i < str.length; i++) {
        answer += str[i];
    }

    return +answer;
}