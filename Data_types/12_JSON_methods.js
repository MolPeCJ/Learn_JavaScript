'use strict';
// Формат JSON, метод toJSON

// Допустим, у нас есть сложный объект, мы хотели бы преобразовать его в строку, чтобы отправить
// по сети или просто вывести для логирования. 
// Естественно, такая строка должна включать в себя все важные свойства: 

let user = {
    name: "John",
    age: 30,
};
  
console.log( user ); // {name: "John", age: 30}

// Но в процессе разработки добавляются новые свойства, старые свойства переименовываются и удаляются. 
// Обновление такого toString каждый раз может стать проблемой. Мы могли бы попытаться перебрать свойства в нём, 
// но что, если объект сложный, и в его свойствах имеются вложенные объекты? 
// Мы должны были бы осуществить их преобразование тоже

// К счастью, нет необходимости писать код для обработки всего этого. 
// У задачи есть простое решение

// JSON.stringify
console.log( 
`\n------------------------
|    JSON.stringify    |
------------------------\n` );

// JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов. 
// Его описание задокументировано в стандарте RFC 4627

// JavaScript предоставляет методы:
// * JSON.stringify - для преобразования объектов в JSON.
// * JSON.parse - для преобразования JSON обратно в объект.

// Например, здесь мы преобразуем через JSON.stringify данные студента:
let student = {
    name: 'John',
    age: 30,
    isAdmin: false,
    courses: ['html', 'css', 'js'],
    wife: null
};

let json = JSON.stringify(student);

console.log( typeof json ); // мы получили строку!

console.log( json ); // выведет объект в формате JSON

// Полученная строка json называется JSON-форматированным или сериализованным объектом. 
// Мы можем отправить его по сети или поместить в обычное хранилище данных.

// Объект в формате JSON имеет несколько важных отличий от объектного литерала:
// * Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так 'John' становится "John".
// * Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так age:30 становится "age":30

// Исключаем и преобразуем: replacer
console.log( 
`\n------------------------------------------------------------------
|    Исключаем и преобразуем: replacer. Форматирование (space)   |
------------------------------------------------------------------\n` );

// Полный синтаксис JSON.stringify:
// let json = JSON.stringify(value, [replacer, space])
// * value - значение для кодирования.
// * replacer - массив свойств для кодирования или функция соответствия function(key, value).
// * space - дополнительное пространство (отступы), используемое для форматирования.

// Обычно используется лишь 1-й аргумент, но если во 2-м передать массив свойств, то
// будут закодированы лишь они!

// Также полезно использовать replacer, так как у него есть возможность проанализировать
// и заменить/пропустить даже весь объект целиком, если это необходимо

// Третий аргумент в JSON.stringify - количество проблеов, используемых для форматирования.
// Например, ниже space = 2 указывает JS отображать вложенные объекты в несколько строк 
// с отступом в 2 пробела внутри объекта:

let user2 = {
    name: "John",
    age: 25,
    roles: {
      isAdmin: false,
      isEditor: true
    }
  };
  
  console.log(JSON.stringify(user2, null, 2));

// Параметр space исключительно для логирования и красивого вывода

// Пользовательский "toJSON"
console.log( 
`\n----------------------------------
|    Пользовательский "toJSON"   |
----------------------------------\n` );

// Как и toString для преобразования строк, объект может предоставлять метод toJSON для преобразования в JSON. 
// JSON.stringify автоматически вызывает его, если он есть.

let room1 = {
    number: 23
};
  
let meetup1 = {
    title: "Conference",
    date: new Date(Date.UTC(2017, 0, 1)),
    room1
};
  
console.log( JSON.stringify(meetup1, null, 2) );

// Сравним

let room2 = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
  
let meetup2 = {
    title: "Conference",
    room2
};

console.log( JSON.stringify(meetup2, null, 2) );

// Как видно, toJSON используется как при прямом вызове JSON.stringify(room), 
// так и когда room вложен в другой сериализуемый объект.

// JSON.parse
console.log( 
`\n--------------------
|    JSON.parse    |
--------------------\n` );

// Чтобы декодировать JSON-строку, нужен другой метод с именем JSON.parse,
// синтаксис: let value = JSON.parse(str, [reviver]);
// *str - JSON для преобразования в объект
// *reviver - необязательная функция, которая будет вызываться для каждой пары (ключ, значение)
// и может преобразовывать значение

// Например: 
let numbers = '[0, 1, 2, 3]';

numbers = JSON.parse(numbers);

console.log( numbers[1] ); // 1

// Идея для вложенных объектов: 
let user4 = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

user4 = JSON.parse(user4);

console.log( user4.friends[1] ); // 1

// Типичные ошибки
let json1 = `{
    name: "John",                       // Ошибка: имя свойства без кавычек
    "surname": 'Smith',                 // Ошибка: одинарные кавычки в значении (должны быть двойными)
    'isAdmin': false                    // Ошибка: одинарные кавычки в ключе (должны быть двойными)
    "birthday": new Date(2000, 2, 3),   // Ошибка: не допускается конструктор "new", только значения
    "friends": [0,1,2,3]                // Здесь всё в порядке
  }`;

// Использование reviver
console.log( 
`\n------------------------------
|    Использование reviver   |
------------------------------\n` );

// Представим, что мы получили объект meetup с сервера в виде строки данных.
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
// А теперь нам нужно десериализировать ее, то есть снова превратить в объект JS.
// Сделаем это через вызов JSON.parse:

let meetup3 = JSON.parse(str);

// console.log( meetup3.date.getDate() ); // Ошибка!
// Значением meetup.date является строка, а не Date объект. 
// Как JSON.parse мог знать, что он должен был преобразовать эту строку в Date?
// Ппередадим JSON.parse функцию восстановления вторым аргументом, 
// которая возвращает все значения «как есть», но date станет Date:

let meetup4 = JSON.parse(str, function(key, value) {
    if (key == 'date') return new Date(value);

    return value;
});
  
console.log( meetup4.date.getDate() ); // 30 - теперь работает! Так будет работать
// и для вложенных объектов!

console.log(
`\n----------------------
|    Задачи (1/2)    |
----------------------\n`);

// Преобразуйте объект в JSON, а затем обратно в обычный объект

let user5 = {
    name: "Anatoly Antsupov",
    age: 21
};

let answer = JSON.parse(JSON.stringify(user5));

console.log( answer.age ); // 21

// Исключить обратные ссылки (!) - эталонный ответ отличается от предоставляемого

let room5 = {
    number: 23
};

let meetup5 = {
    title: "Reunion",
    occupiedBy: [{name: "Shelokov"}, {name: "Nikita"}],
    place: room5
};

// цикличные ссылки
room5.occupiedBy = meetup5;
meetup5.self = meetup5;

console.log( JSON.stringify(meetup5, function replacer(key, value) {
    console.log( `${key}: ${value}` );

    return (key == 'occupiedBy' || key == 'self') ? undefined : value;
}));