// Управление памятью в JavaScript выполняется автоматически и незаметно.

// Достижимость 

// Основной концепцией управления памятью JavaScript является принцип достижимости.
// Если упростить, то "достижимые" значения - это те, которые доступны или используются. 
// Они гарантировано находятся в памяти. 

// 1. Существует базовое множество достижимых значений, которые не могут быть удалены:
// - Локальные переменные и параметры текущей функции
// - Переменные и параметры других функций в текущей цепочке вложенных вызовов
// - Глобальные переменные
// - (некоторые другие внутренние значения) - корни

// 2. Любое другое значение считается достижимым, если оно доступно из корня по ссылке
// или по цепочке ссылок. Например, если в локальной переменной есть объект, и он имеет
// свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. 
// И те, на которые он ссылоается, тоже достижимы.

// В интерпретаторе JS есть фоновый процесс, называестя "сборщик мусора" - 
// следит за всеми объектами и удаляет те, которые стали недостижимы.

// Простой пример

let user = {
    name: "Jhon"
};
// <global> -> Object(name: "Jhon")
// Здесь стрелка обозначает ссылку на объект. Глобальная переменная user ссылается на
// объект {name: "Jhon"}. Если переписать значение user, то ссылка потеряется.
user = null;
// Теперь объект становится недостижимым. К нему нет доступа, на него нет ссылок. 
// Сборщик мусора удалит эти данные и освободит память

// Две ссылки 

// Представим, что мы скопировали ссылку из user в admin:
let user1 = {
    name: "Jhon"
};

let admin = user1;
// Теперь сделаем то же самое: 
user1 = null;
// Объект все еще достижим через глобальную переменную admin, поэтому он находится
// в памяти. Если бы мы также перезаписали admin, то объект был бы удален. 

// Взаимосвязанные объекты

function marry(man, woman) {
    man.wife = woman;
    woman.husband = man;

    return {
        father: man,
        mother: woman
    }
}

let family = marry({
    name: "Jhon"
}, {
    name: "Ann"
});
// Функция marry "женит" два объекта, давая им ссылки друг на друга, и возвращает новый
// объект, содержающий ссылки на два предыдущих. То есть, получается что-то вроде
// <global variable> -> family (Object) -> father (Object) -> wife
//                                      -> mother (Object) -> husband
// На данный момен твсе объекты достижимы. 
// Теперь удалим 2 ссылки:
delete family.father;
delete family.mother.husband;
// Недостаточно удалить только одну из ссылок, потому что все объекты останутся достижимы.
// Но если мы удалим обе, то увидим, что у объекта father больше нет входящих ссылок. 
// Исходящие же ссылки (wife) не имеют значения. Только входящие могут сделать 
// объект достижимым. Объект теперь недостижим и будет удален из памяти со всеми своими 
// данными, которые также стали недоступны. 

// Недостижимый "остров"

// Вполен возможна ситуация, при которой целый "остров" связанных объектов может стать
// недостижимым и удалиться из памяти. 
// Возьмем объект family из примера выше до манипуляций с delete. А затем: 
family = null;
// Объекты могут быть еще связанными, оба даже могут иметь входящие ссылки, но этого
// недостаточно. У объекта family больше нет ссылки от корня, поэтому весь "остров"
// становится недостижимым и будет удален

// Внутренние алгоритмы (в пособии представлены замечатльные иллюстрации)

// Основной алгоритм сборки мусора - "алгоритм пометок"
// Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги: 
// 1. "Помечает" (запоминает) все корневые объекты
// 2. "Помечает" объекты по их ссылкам
// 3. "Помечает" объекты по ссылкам помеченных объектов и так далее
// 4. Все непомеченные объекты удаляются