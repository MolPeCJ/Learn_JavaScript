// Тип данных Symbol

// Символы
// "Символ" представляет собой уникальный идентификатор.
// Создаются новые символы с помощью функции Symbol():
let id1 = Symbol("id");
// При создании символу можно дать описание (также называемое имя), в основном
// использующееся для отладки кода:
let id2 = Symbol("id");
// Символы гарантированны уникальны. Даже если описание - просто метка - будет одинаковым
// с другим описанием, символы все равно будут не равны
console.log(id1 == id2); // false

// Символы не преобразуются автоматически в строки
let id3 = Symbol("id");

console.log(id3); // c console.log получилось, с alert - ошибка
console.log(id3.toString()); // правильный вариант
// или мы можем обратиться к свойству symbol.description, чтобы вывести только описание
let id4 = Symbol("id");
console.log(id4.description); // id

// "Скрытые" свойства
// Символы позволяют создавать "скрытые" свойства объектов, к которым нельзя нечаянно обратиться
// и перезаписать их из других частей программы. 
// Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить
// к ним идентификаторы. Используем для этого символьный ключ: 
let user = {
    name: "Vasya"
};

let id5 = Symbol("what");

user[id5] = 1;

console.log( user[id5] ); // 1, получаем доступ к данным по ключу-символу
// Почему же лучше использовать Symbol("id"), а не строку "id"?
// Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не
// следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно
// обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не
// вызовет никаких проблем. 

let user2 = {
    name: "Kolya"
};

// С помощью символов можно создать объект с абсолютно уникальными свойствами

let person = {
    age: 20,
    name: "Tolya",
    [Symbol.for("password")]: "Tolya21"
};

console.log(person);
console.log(person[Symbol.for("password")]);
console.log(Object.getOwnPropertySymbols(person));

// Символы в литеральном объекте
// Если мы хотим использовать символ при литеральном объявлении объекта, его необходимо
// заключить в квадртаные скобки
let id6 = Symbol("id");
let user3 = {
    name: "Olya",
    [id6]: 123
};

// Символы игнорируются циклом for...in (!)
// Свойства, чьи ключи - символы, не перебираются циклом for...in
let password = Symbol("password");
let user4 = {
    name: "Jhon",
    age: 21,
    [password]: 12345
};

for (let key in user4) { console.log(key) }; // name, age - ЭВРИКА, ВОТ ЗАЧЕМ СИМВОЛЫ

console.log( user4[password] ); // хотя напрямую работает, так и задумано
// Это - часть принципа "сокрытия символьных свойств". Если другая библиотека или скрипт
// будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное
// свойство. Object.keys(user) также игнорирует символы. 

// А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
let password1 = Symbol("password1");
let user5 = {
    name: "Tonya",
    [password1]: 1234
};

let clone = Object.assign({}, user5);

console.log( clone[password1] ); // 1234

clone.name = "Vasi";
console.log(clone.name);
// Здесь нет никакого противоречия или парадокса. Так и задумано. Идея заключается в том, что, когда
// мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства (включая такие
// свойства с ключами-символами, как, например, password1 в примере выше)

// Глобальные символы (cодержащиеся в реестре)
// Иногда мы хотим, чтобы символы с одинаковыми именами были одной сущностью. 
// Для этого существует глобальный реестр символов. Мы можем создавать в нем символы и обращаться
// к ним позже, и при каждом обращении нам гарантировано будет возвращаться один
// и тот же символ. 
// Для чтения (или, при отсутствии, создания) символа из реестра используется вызов
// Symbol/for(key) - он проверяет глобальный реестр и, при наличии в нем символа с именем
// key, возвращает его, иначе же создается новый символ Symbok(key) и записывается в реестр
let id7 = Symbol.for("id");

let idAgain = Symbol.for("id");

console.log( id7 === idAgain ); // true

// Symbol.keyFor
// Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует
// обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и 
// возвращает его имя
let sym = Symbol.for("name");
let sym2 = Symbol.for("age");
// получаем имя по адресу
console.log( Symbol.keyFor(sym) ); // name
console.log( Symbol.keyFor(sym2) ); // age

// Системные символы
// Вернуться и посмотреть после изучения доп. возможностей языка