"use strict";
// Объекты обычно создаются, чтоблы представлять сущности реального мира, будь то
// пользователи, заказы и так далее: 
// Объект пользователя
let user = {
    name: "Jhon",
    age: 30
};
// И так же, как и в реальном мире, пользователь может совершать действия: выбирать
// что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.
// Такие действия в JavaScript представлены свойствами-функциями объекта

// Примеры методов

// Для начала научим нашего пользователя user1 здороваться
let user1 = {
    name: "Tony",
    age: 30
};

user1.sayHi = function() {
    console.log( "Hello, world! I'm Tony" );
};

user1.sayHi(); // Hello, world! I'm Tony
// Здесь мы просто использовали Function Expression (функциональнео выражение), чтобы создать
// функцию для приветствия, и присвоили ее свойству user.sayHi наешего объекта.
// Затем мы вызвали ее, и теперь user1 может говорить!
// Функцию, которая является свойством объекта, называется методом этого объекта. 
// Итак, мы получили метод sayHi объекта user1
// Можно было сделать и немного иначе
let user2 = {
    name: "Mike",
    age: 30
};

function sayHello() {
    console.log( "Hello, world! ");
}

user2.sayHello = sayHello;

user2.sayHello(); // Hello, world!

// Объектно-оринетированное программирование
// Когда мы пишем код, используя объекты для представления сущностей реального мира, 
// - это называется объектно-оринетированное программирвоание или сокращенно: "ООП"

// Сокращенная запись метода

// Существует более короткий синтаксис для методов в литерале объекта:
let user3 = {
    sayHi: function() {
        console.log( "Hello!" );
    }
};
// Эти объекты делают одно и то же (одинаковые методы)
// Но надо заметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с
// наследованием объектов (что будет рассмотрено позже), но на данном этапе изучения неважно
let user4 = {
    sayHi() {
        console.log( "Hello!" );
    }
};
// Как было показано, мы можем пропустить ключевое слово "function" и просто написать sayHi()

// Ключевое слово "this" в методах

// Как правило, методу объекта необходим доступ к информации, которая хранится в 
// объекте, чтобы выполнить с кей какие-либо действия (в соответсвии с назначением метода).
// Например, коду внутри user.sayHi() может понадобиться имя пользователя, которое хранится
// в объекте user. 
// Для доступа к информации внутри объекта метод может использовать ключевое слово "this"
// Значение this - это объект "перед точкой", который использовался для вызова метода
let user5 = {
    name: "Jhon",
    age: 30,

    sayHi() {
        console.log(this.name)
    }
};

user5.sayHi(); // Джон
// Здесь во время выполнения кода user.sayHi() значением this будет являться user (ссылка на объект user)
// Технически также возможно получить доступ к объекту без ключевого слова this, ссылаясь на него через
// внешнюю переменную (в которой хранится ссылка на этот объект)
let user6 = {
    name: "Keny",
    age: 30,

    sayHi() {
        console.log(user6.name); // используем переменную "user" вместо ключевого "this"
    }
}

// Но такой код будет ненадежным. Если мы решим скопировать ссылку на объект user в другую переменную, 
// например, admin = user, и перезапишем переменную user чем-то другим, тогда будет осуществлен доступ
// к неправильном объекту при вызове метода из admin. 
// Поэтому стоит использовать this.name вместо user.name, тогда код будет работать

// "this" не является фиксированным
// В JavaScript ключевое слово "this" ведет себя иначе, чем в большинстве других языков программирования.
// Оно может использоваться в любой функции
let user7 = { name: "Katya" };
let admin = { name: "Sonya" };

function sayHi() {
    console.log(this.name);
}

user7.f = sayHi;
admin.f = sayHi;

user7.f(); // Katya
admin.f(); // Sonya

// При этом вызов без объекта: this == undefined (только при использовании "use strict").
// В противном случае будет ошибка
function sayHitoshi() {
    console.log(this)
}

sayHitoshi(); // undefined

// Последствия свободного this

// В JS this является "свободным", его значение вычисляется в момент вызова и не зависит
// от того, где этот метод был объявлен, а зависит от того, какой объект вызывает метод (какой
// объект стоит "перед точкой").
// Эта идея вычисления this в момент исполнения имеет как свои плюсы, так и минусы. С одной стороны, 
// функция может быть повторно использована в качестве метода у различных объектов (что повышает
// гибкость). С другой стороны, большая гибкость увеличивает вероятность ошибок. 
// Мы не судим о том, является ли это решение в языке хорошим или плохим. Мы должны
// понимать, как с этим работать, чтобы получать выгоды и избегать проблем

// Внутренняя реализация: Ссылочный тип

// У стрелочных функций нет "this"

// Стрелочные функции особенные: у них нет своего "собственного" this. Если мы используем this внутри
// стрелочной функции, то его значение берется из внешней "нормальной" функции.
// Например, в примере ниже arrow() использует значение this из внешнего метода user.sayHi()
let userEnd = {
    firstName: "Ilya",
    sayHi() {
        let arrow = () => console.log(this.firstName);
        arrow();
    }
};

userEnd.sayHi(); // Ilya
// Это является особенностью стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь
// отдельное значение this, а хотим брать его из внешнего контекста

/////////////////////////////////////////////
///////////// Questions (1/5) ///////////////
/////////////////////////////////////////////

// Extra question (!)
// Результатом выполнения кода будет: 
// Ответил неправильно, увидел ошибку в исполнении функции, а она была в пропущенный ; после let

// Extra question (!)
// Не понял причину вывода на экран undefined
// Ответ следующий: сложный вызов (expression).method() работает только при разделении на 2 строчки

// Using "this" in object literal
// Да, здесь ошибка, неизвестно что за name

// Create a calculator (!)
// Команда ввода информации в node.js иначе выглядит, не prompt. В песочнице код работает
let calculator = {
    read() {
        this.theFirstNumber = +prompt( "Enter the first number", "" );
        this.theSecondNumber = +prompt( "Enter the second number", "" );
    },
    sum() {
        return(this.theFirstNumber + this.theSecondNumber);
    },
    mul() {
        return(this.theFirstNumber * this.theSecondNumber);
    }
};

calculator.read();
console.log( calculator.sum() );
console.log( calculator.mul() );
// Написал точно такой же код, только не написал this в return-ax, поэтому не сработал

// Chaining (!)
let ladder = {
    step: 0,
    up() {
        this.step++;
        return this; // возврат самого объекта в методе
    },
    down() {
        this.step--;
        return this; 
    },
    showStep: function() {
        console.log( this.step );
        return this; 
    }
};

ladder
    .up()
    .up()
    .down()
    .showStep(); // более читабельный код
// То есть, чтобы можно было сделать несколько последовательных вызовов в цепочке (не с новой строчки,
// а именно в цепочки), то для этого необходимо добавить возврат самого объекта в каждом методе!