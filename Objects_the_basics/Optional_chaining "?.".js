// Опциональная цепочка ?. - это безопасный способ доступа к свойствам вложенных объектов,
// даже если какое-либо из промежуточных свойств не существует. 

// Проблема "несуществующего свойства"

// Так как мы только начали читать учебник и изучать JavaScript, нас данная проблема
// еще не консулась, но она довольно распространена.
// В качестве примера предположим, что у нас есть объекты user, которые содержат информацию о
// наших пользователях.
// У большинства наших пользователей есть адреса в свойсте user.address с улицей
// user.address.street, но некоторые из них их не указали.
// В таком случае, когда мы пытаемся получить user.address.street, а пользователь окажется
// без адреса, мы получим ошибку:
/*let user = {};

console.log(user.address.street);*/ // Ошибка!
// Это ожидаемый результат. JS работает следующим образом. Поскольку user.address
// имеет значение undefined, попытка получить user.address.street завершается ошибкой.
// Во многих практических случаях мы бы предпочли получить здесь undefined вместо ошибки (что
// означало бы "улицы нет"). 
// Или еще один пример. В веб-разработке мы можем получить объект, соответствующий элементу
// веб-страницы, с помощью специального вызова метода, такого как document.querySelector('.elem'),
// и он возвращает null, когда такого элемента нет. 
// Как мы можем сделать это здесь?
// Очевидным решением было бы проверить значение с помощью if или условного оператора ?,
// прежде чем обращаться к его свойству, вот так:
let user1 = {};

console.log(user1.address ? user1.address.street : undefined);
// Это работает без ошибки, но это довольно неэлегантно. Как вы можете видеть, 
// user.address появляется в коде дважды.
// Для более глубоких вложенных свойств это еще менее красиво, поскольку потребуется больше
// повторений. К примеру, вычислим user.address.street.name:
let user2 = {};

console.log(user2.address ? user2.address.street ? user2.address.street.name : undefined : undefined);
// Это просто ужасно, могут даже возникнуть проблемы с пониманием такого кода. 
// Есть немного лучший способ написать это, используя оператор &&:
let user3 = {};

console.log(user3.address && user3.address.street && user3.address.street.name) // undefined
// Проход при помощи логического оператора И && через весь пусть к свойству гарантирует. что все
// компоненты существуют (если нет, вычисление прекращатеся), но также не является идеальным,
// ведь имена свойства по-прежнему дублируются в коде.
// Вот почему в язык была добавлены опциональная цепочка ?. 
// Чтобы решить эту проблему - раз и навсегда!

// Опциональная цепочка

// Опциональная цепочка ?. останавливается вычисление и возвращает undefined, если значение
// перед ?. равно undefined или null. 
// Другими словами, value?.prop:
// работает как value.prop, если значение value существует,
// в противном случае (когда value равно undefined/null) он возвращает undefined.
let user4 = {};

console.log(user4?.address?.street); // undefined (без ошибки)
// Считывание адреса с помощью user?.address работает, даже если объект user не существует:
let user5 = null;

console.log(user5?.address); // undefined
console.log(user5?.address?.streer); // undefined

// Не злоупотребляй опциональной цепочкой, используй правильно

// Следует использовать ?. только там, где нормально, что чего-то не существует.
// К примеру, если, в соответствии с логикой нашего кода user должен существовать,
// но adress является необязательным, то нам следует писать user.address?.street, но
// не user?.address.street!
// В этом случае, если вдруг user окажется undefined, мы увидим программную ошибку по
// этому поводу и исправим ее. В противном случае, если слишком часто использовать ?.,
// ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать

// Переменная перед ?. должна быть объявлена!

// Если переменной user вообще нет, то user?.anything приведет к ошибке:
//user6?.address; user6 is not defined

// Сокращенное вычисление

// Как было сказано ранее, ?. немедленно останавливает вычисление, если левая часть
// не существует. Так что если после ?. есть какие-то вызовы функций или операции, то
// они не произойдут. 
let user7 = null;
let x = 0;

user7?.sayHi(x++); // нет user, поэтому выполнение не достигает вызова sayHi

console.log(x); // 0

// Другие ваиранты применения: ?.(), ?.[]

// Опциональная цепочка ?. - это не оператор, а специальная синтаксическая конструкция, которая
// также работает с функциями и квадратными скобками.
// Например, ?.() используется для вызова функции, которая может не существовать
let userAdmin = {
    admin() {
        console.log( "I am admin" );
    }
};

userAdmin.admin?.(); // I am admin

let key = "firstName";

let user8 = {
    firstName: "Jhon"
};

let user9 = null;

console.log( user8?.[key] ); // Jhon
console.log( user9?.[key] ); // undefined

// Также мы можем использовать ?. с delete:
delete user8?.firstName;