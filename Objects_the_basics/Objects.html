<!DOCTYPE html>
<html>
    <body>

        <script>
            "use strict";
            // Объекты - непримитивный тип данных, так как хранит в себе не одно значение,
            // а коллекцию различных значений и более сложных сущностей. 

            // Объекты можно сравнить ящиком, в котором лежат папки - свойства. 
            // Каждое свойство представляет собой пару: ключ: значение. По ключу папку легко
            // найти, удалить или добавить в нее что-либо!
            
            // Пустой объект ("пустой ящик") можно создать, используя один из двух вариантов синтаксиса:
            let user = new Object(); // синтаксис "конструктор объекта"
            let user1 = {}; // синтаксис "литерал объекта" или "литеральная нотация" - мне больше нравится!

            // Литералы и свойства
            
            // При использовании литерального синтаксиса мы сразу можем поместить в объект несколько
            // свойств в виде пар "ключ: значение"
            let user2 = {     // Объект
                name: "Jhon", // под ключом "name" хранится значение "Jhon"
                age: 30       // под ключом "age" хранится значение 30
            }

            // Мы можем в любой момент добавить в user2 новые папки, удалить или прочитать содержимое
            alert( user2.name ); // Jhon
            alert( user2.age );  // 30
        
            // Добавим и удалим user2 свойство со значением логического типа
            user2.isAdmin = true;
            alert( user2.isAdmin ); // true
            
            delete user2.isAdmin;
            alert( user2.isAdmin ); // undefined

            // Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки
            const user3 = {
                name: "Jhon",
                age: 30,
                "likes birds": true // имя свойства заключается в кавычки
            }

            // Интересные моменты: последнее свойство может иметь запятую на конце. Это называется "висячая запятая".
            // Если бы user3 был const, а не let, изменить свойства все равно можно было бы

            // Квадратные скобки

            // Для свойств, имена которых состояит из нескольких слов, доступ к значению "через точку" не работает. Для
            // таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки
            let user4 = {}; // создаем объект

            user4["likes birds"] = true;   // одновременно создаем и присваиванием значение свойству

            alert( user4["likes birds"] ); // true

            delete user4["likes birds"];   // удаляем свойство

            alert( user4["likes birds"] ); // undefined

            // Квадратные скобки также позволяют обратиться к свойству, имя которого это результат выражения
            let key = "likes birds";

            user4[key] = true;

            alert( user4["likes birds"] ); // true

            // А вот еще один пример, показывающий возможности применения [] вместо .
            let key1 = prompt( "What do you want to know about user4?", "likes birds" );

            alert( user4[key1] ); // true, если ввод "likes birds"

            // Вычисляемые свойства

            // Мы можем использовать [] для создания вычисляемого свойства в литеральной нотации
            let fruit = prompt( "What fruit do you prefer?", "banana" );
            
            let bag = {
                [fruit]: 5 // имя свойства будет взято из переменной fruit
            }
            // Аналог записи: bag[fruit] = 5, но первый вариант выглядит лаконичнее

            alert( bag.banana ); // 5, если fruit = "banana"

            // Итог: в большинстве случае, когда имена свойств известны и просты, используется запись
            // через точку. Если же нужно что-то более сложное, то используем квадратные скобки []

            // Свойство из переменной

            // В реальном коде часто нам необходимо использовать существующие переменные как значения для
            // свойств с тем же имененем. Например:
            function makeUser(name, age) {
                return {
                    name: name, // можно было просто name, названия совпадают
                    age: age    // можно было просто age, названия совпадают
                };
            }

            let user5 = makeUser("Jhon", 30);

            alert( user5.name ); // Jhon
            
            // В примере выше названия свойств совпадают с названиями локальных переменных. Такой подход очень 
            // распространен и существуют специальные короткие свойства для упрощения этой записи (написано выше)

            // Ограничения на имена свойств

            // Спойлер: никаких органичений нет, можно использовать даже специальные зарезервированные слова
            // наподобие "for", "let", "return" и других. Можно даже числа использовать, только все типы данных
            // будут автоматически преобразовываться к строке (0 -> "0")
            
            // Attention! Если только подводный камен со словом __proto__, но его мы разберем в следующих уроках

            // Проверка существования свойства, оператор "in"

            // В отличие от многие других языков, особенность JavaScript-объектов в том, что можно получить
            // доступ к любому свойству. Даже если свойства не существует - ошибки не будет! Будет undefined
            let user6 = {
                name: "Mikel"
            }

            alert( user6.name ); // Mikel
            alert( user6.age );  // undefined

            // Существование свойства можно проверить "свойство" === undefined. Существует и специальный
            // оператор "in" для проверки. Синтаксис оператора: "key" in object.
            // Если мы опускаем кавычки в "key", значит мы указываем переменную, в которой находится имя свойства
            let user7 = { name: "Jhon", age: 30 };
            let nameUser7 = "name";

            alert( "age" in user7 );     // true
            alert( "example" in user7 ); // false
            alert( nameUser7 in user7 ); // true

            // Можно использовать и оператор, и сравнение с undefined. Для оператора есть особый случай, когда он
            // необходим: если в значении свойства указано undefined. Но это крайне редко, обычно для "неизвестных"
            // bkb "пустых" свойств мы используем значение null

            // Цикл "for...in"

            // Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от 
            // изученного ранее цикла for(;;). Синтаксис: for (key in object) { тело выполняется для каждого свойства }
            let user8 = {
                name: "Tolya",
                age: 20,
                isAdmin: true
            }

            for (let key in user8) { // или let prop in obj
                alert( key );        // name, age, isAdmin
                alert( user8[key] ); // Tolya, 20, true
            }

            // Упорядочение свойств объекта

            // Упорядочены ли свойства объекта? Ответ: свойства упорядочены следующим образом: свойства с 
            // целочисленными ключами сортируются по возрастанию (1-2-3-4...), остальные располагаются 
            // в порядке создания
            let codes = {
                "49": "Germany", // "+49"
                "41": "Portu", // "+41"
                "44": "Great Britain", // "+44"
                "1": "USA" // "+1"
            }

            for (let code in codes) {
                alert( code ); // 1, 41, 44, 49
            }

            // Целочисленное свойство означает строку, которая может быть преобразована в целое число
            // и обратно без изменений: "49". Не "+49" и не "1.2", а только "49" и т.п. 

            // То есть, чтобы решить проблему с номерами, достаточно добавить + к номеру (сделал выше), и
            // цифры числа будут располагаться в порядке создания (49-41-44-1)

            /////////////////////////////////////////////
            ///////////// Questions (4/5) ///////////////
            /////////////////////////////////////////////

            // Hello, object
            let user9 = {};

            user9.name = "Jhon";
            user9.surname = "Smith";

            alert( user9.name ); // Jhon

            user9.name = "Pete";

            alert( user9.name ); // Pete

            delete user9.name;

            alert( user9.name ); // undefined

            // Check for emptiness
            let schedule = {};

            function isEmpty(obj) {
                for (let key in obj) {
                    return false;
                }

                return true;
            }

            alert( isEmpty(schedule) );

            schedule["8:30"] = "get up";

            alert( isEmpty(schedule) );

            // Sum object properties
            // Да, ключи константного объекта поддаются изменениям, ведь 
            // меняется не сам объект, а его содержимое

            // Multiply numeric property values by 2 (!)
            let salaries = {
                John: 100,
                Ann: 160,
                Pete: 130
            }

            function increment(obj) {
                if (isEmpty(obj)) {
                    return 0;
                }

                let sum;

                sum = obj.John + obj.Ann + obj.Pete;

                return sum;
            }

            function isEmpty(obj) {
                for (let key in obj) {
                    return false;
                }

                return true;
            }

            alert( increment(salaries) );

            // Первоначально написал абсолютно такой же код, как и в ответе. НО! Он выдавал NaN, так как
            // я не указал let sum = 0 (было просто let sum). Потом написал данный код, тоже рабочий

            // Multiply numeric property values by 2 (!)
            let menu = {
                width: 200,
                height: 300,
                title: "my menu"
            }

            for (let key in menu) {
                alert( menu[key] );
            }

            function multiplyNumeric(obj) {
                for (let key in obj) {
                    if (typeof (obj[key]) == "number") {
                        obj[key] *= 2;
                    }
                }
            }

            multiplyNumeric(menu);

            for (let key in menu) {
                alert( menu[key] );
            }

            // Сделал проверку для задания выше и все было ок, смотрю тест не проходит и недоумеваю. Вижу, 
            // входные данные должны быть другими) Опа, задание полетело из-за невнимательности, а код правильный
            </script>

    </body>
</html>