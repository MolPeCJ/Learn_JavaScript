<!DOCTYPE html>
<html>
    <body>

        <script>
            "use strict";
            // Одним из фундаментальных отличий объектов от примитивных типов данных является то, 
            // что они хранятся и копируются "по ссылке". 
            // То есть, переменная хранит не сам объект, а его "адрес в памяти", другими словами "ссылку"
            // на него
            let user = {
                name: "Ivan"
            };
            // Сам объект хранится в памяти. А в переменной user лежит "ссылка" на эту области памяти.
           
            // Когда переменная объекта копируется - копируется ссылка, сам же объект не дублируется.
            // Можно представить, что объект это ящик, а переменная - ключ к нему. Копирование 
            // переменной дублирует ключ, но не сам ящик
            let user1 = { name: "Ivan" };
            let admin = user1; // копируется ссылка
            // Теперь у нас есть 2 переменные, каждая из которых содержит ссылка на один и тот же объект
            
            // Мы можем использовать любую переменную для доступа к ящику и изменения его содержимого
            let user2 = { name: "Ivan" };
            let admin1 = user2;

            admin1.name = "Petere"; // изменено по ссылки из переменной "admin"

            alert( user2.name ); // "Petere", изменения видны по ссылке из переменной user2

            // Сравнения по ссылке

            // Операторы равенства == и строгого равенства === для объектов работают одинаково.
            // Два объекта равны только в том случае, если это один и тот же объект.
            // В примере ниже две переменные равны, потому что ссылаются на один и тот же объект
            let a = {};
            let b = a;

            alert( a === b ); // true 
            alert( a == b );  // true

            // В другом примере два разных объекта не равны, хотя оба пусты
            let a1 = {};
            let b1 = {};

            alert( a1 == b1 ); // false

            // Клонирование и объединение объектов, Object.assign

            // При копировании переменной с объектом создается еще одна ссылка на тот же самый объект.
            // Но что, если нам нужно дублировать объект? Создать независимую копию, клон?
            // Это выполнимо, но немного сложнее. На самом деле такая нужда возникает редко. В
            // большинстве случаев достаточно копирования по ссылке.
            // Но если мы действительно этого хотим, то нам нужно создать новый объект и повторять
            // структуру дублируемого объекта, перебирая все свойства и копируя их
            let user3 = {
                name: "Ivan",
                age: 30
            };
            
            let clone = {};

            for (let key in user3) {
                clone[key] = user3[key];
            }

            clone.name = "Petere";

            alert( user.name );  // Ivan
            alert( clone.name ); // Petere

            // Кроме того, для этих целей мы можем использовать метод Object.assign. 
            // Метод копирует свойства всех исходных объектов в dest и возвращает его
            // Синтаксис: Object.assign(dest, [src1, src2, src3...])
            // dest - целевой объект
            // scr1, ..., scrN - исходные объекты
            // Если принимающий объект уже имеет свойство с таким именем, оно будет перезаписано
            let user4 = {
                name: "Jhon",
                age: 21
            }

            let permission1 = { canView: true };
            let permission2 = { canEdit: true };

            Object.assign(user4, permission1, permission2);

            for (let key in user4) {
                alert( key ); // name, age, canView, canEdit
            }

            // Конечно же, Object.assign можно использовать вместо for..in
            let clone1 = Object.assign({}, user4);

            alert( clone1.name ); // Jhon

            // Вложенное клонирование

            // До сих пор мы предполагали, что все свойства объекта хранят примитивные значения.
            // Но свойства могут быть ссылками на другие объекты. Что с ними делать?
            let user5 = {
                name: "Ivan",
                age: 30,
                sizes: {
                    height: 182,
                    width: 50
                }
            };
            // Теперь при клонировании недостаточно просто скопировать clone.sizes = user.sizes,
            // поскольку user.sizes - это обЪект, он будет скопирован по ссылке. А значит объекты
            // clone и user в своих свойствах sizes будут ссылаться на один и тот же объект
            let clone2 = Object.assign({}, user5);

            alert( clone2.sizes == user5.sizes ) // true, это один и тот же объект

            user5.sizes.width++; // меняем свойство в одном объекте

            alert( clone2.sizes.width ) // 51, видим результат в другом объекте

            // Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли
            // значение user[key] объектом, и если это так - скопировать и его структуру тоже. Это
            // называется "глубокое клонирование"
            // P.S. Код ниже не работает :(
            /* let clone3;

            for (let key in user5) {
                if (typeof(user5[key]) == "object") {
                    for (let key1 in key) {
                        clone3[key][key1] = user5[key][key1];
                    }
                
                clone3[key] = user5[key];
                }
            }

            for (let key in clone3) {
                alert( key ); // name, age, canView, canEdit
            }*/
            // Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не
            // изобретать велосипед, использовать готовую реализацию - метод _.cloneDeep(obj) из
            // JavaScript-библиотека lodash
        </script>

    </body>
</html>